# P1160 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 输入格式

第一行一个整数 $N$，表示了有 $N$ 个同学。

第 $2\sim N$ 行，第 $i$ 行包含两个整数 $k,p$，其中 $k$ 为小于 $i$ 的正整数，$p$ 为 $0$ 或者 $1$。若 $p$ 为 $0$，则表示将 $i$ 号同学插入到 $k$ 号同学的左边，$p$ 为 $1$ 则表示插入到右边。

第 $N+1$ 行为一个整数 $M$，表示去掉的同学数目。

接下来 $M$ 行，每行一个正整数 $x$，表示将 $x$ 号同学从队列中移去，如果 $x$ 号同学已经不在队列中则忽略这一条指令。

## 输出格式

一行，包含最多 $N$ 个空格隔开的整数，表示了队列从左到右所有同学的编号。

## 输入输出样例 #1

### 输入 #1

```
4
1 0
2 1
1 0
2
3
3
```

### 输出 #1

```
2 4 1
```

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。

### 题解
```cpp
#include<iostream>
using namespace std;

const int N = 1e5 + 10;
int pre[N], ne[N], e[N];
int h, id, n;
int mp[N];

void push_back(int p, int x)
{
	id++;
	e[id] = x;
	mp[x] = id;
	pre[id] = p;
	ne[id] = ne[p];
	pre[ne[p]] = id;
	ne[p] = id;
}

void push_front(int p, int x)
{
	id++;
	e[id] = x;
	mp[x] = id;
	ne[id] = p;
	pre[id] = pre[p];
	ne[pre[p]] = id;
	pre[p] = id;
}

void erase(int k)
{
	int p;
	p = mp[k];
	if (p != 0)
	{
		mp[k] = 0;
		ne[pre[p]] = ne[p];
		pre[ne[p]] = pre[p];
	}
}

int main()
{
	cin >> n;
	id++;
	e[id] = 1;
	pre[id] = h;
	ne[id] = ne[h];
	ne[h] = id;
	mp[1] = id;
	int t = n - 1;
	for (int i = 2; i <= n; i++)
	{
		int a, b;
		cin >> a >> b;
		if (b == 0)
		{
			push_front(mp[a], i);
		}
		else
		{
			push_back(mp[a], i);
		}
	}
	int m;
	cin >> m;
	while (m--)
	{
		int k;
		cin >> k;
		erase(k);
	}

	for (int i = ne[h]; i; i = ne[i])
	{
		cout << e[i] << " ";
	}
	cout << endl;

	return 0;
}
```

## 优化：
注意到，题目中所给出的值依旧是按照输入的行数规律分布：
所以完全不需要下面的几个东西：

```cpp
int id, e[N];
```

上述代码的实现过程中，涉及左边插和右边插的问题，但是众所周知，在链表中插入节点需要的不是基准点的存储值而是其下标，所以在上面的实现中是通过mp数组将对应的值和下标联系起来，并且通过对应的值返回下标，但是这样的操作真的有必要吗？

但是，由于这个地方，学生的编号本身就是规律且连续的数字，那么我们可以直接调用数组的下标当做e[N]数组，不在加入新的数值或进行修改，每个值的坐标以及唯一且确定，就是这个数值本身；

```cpp
for(int i = 2; i<= n; i++)
{
	int k, p;
	cin >> k >> p;
	if(p == 0)
	{
		ne[i] = k;
		pre[i] = pre[k];
		ne[pre[k]] = i;
		pre[k] = i;
	}
}
```

### 重写版本：
```cpp

#include<iostream>
using namespace std;

const int N = 1e5 + 10;
int ne[N], h, n, pre[N];
int mp[N];

int main()
{
	cin >> n;
	ne[h] = 1;
	pre[1] = h;
	mp[1] = 1;
	for (int i = 2; i <= n; i++)
	{
		int k, q;
		cin >> k >> q;
		if  (q == 0)
		{
			ne[i] = k;
			pre[i] = pre[k];
			ne[pre[k]] = i;
			pre[k] = i;
			mp[i] = i;
		}
		else
		{
			pre[i] = k;
			ne[i] = ne[k];
			pre[ne[k]] = i;
			ne[k] = i;
			mp[i] = i;
		}
	}

	int m;
	cin >> m;
	while (m--)
	{
		int t;
		cin >> t;
		if (!mp[t])
		{
			continue;
		}
		ne[pre[t]] = ne[t];
		pre[ne[t]] = pre[t];
		pre[t] = -1;
		mp[t] = 0;
	}

	//输出：
	for (int i = ne[h]; i; i = ne[i])
	{
		cout << i << " ";
	}
	cout << endl;
	return 0;
}
```
==这个地方创建mp数组单纯是为了检测元素有无被删除==
