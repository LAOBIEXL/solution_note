# P1305 新二叉树

## 题目描述

输入一串二叉树，输出其前序遍历。

## 输入格式

第一行为二叉树的节点数 $n$。($1 \leq n \leq 26$)

后面 $n$ 行，每一个字母为节点，后两个字母分别为其左右儿子。特别地，数据保证第一行读入的节点必为根节点。

空节点用 `*` 表示

## 输出格式

二叉树的前序遍历。

## 输入输出样例 #1

### 输入 #1

```
6
abc
bdi
cj*
d**
i**
j**
```

### 输出 #1

```
abdicj
```

### 分析：
这个二叉树的节点是用字母表示的，是否依旧可以使用两个左右数组来链式存储呢，鉴于字母同样是整形，所以不要使用从1到n的循环来代表节点，而是针对每一个字母作为下标即可实现存储！

### 题解：
传统版：
```cpp
//新二叉树：

#include<iostream>
using namespace std;

const int N = 30;
char l[N], r[N];
char e[N];
int n;
int mp[128];

void dfs1(char i)
{
	cout << i ;
	if(l[mp[i]] != '*')  dfs1(l[mp[i]]);
	if(r[mp[i]] != '*')  dfs1(r[mp[i]]);
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> e[i];
		mp[e[i]] = i;
		cin >> l[i] >> r[i];
	}

	dfs1(e[1]);
}
```

### 优化：
```cpp
#include<iostream>
using namespace std;

const int N = 300;
char l[N], ri[N];
char r;
int  n;

void dfs(char r)
{
	cout << r;
	if (l[r] != '*') dfs(l[r]);
	if (ri[r] != '*') dfs(ri[r]);
}

int main()
{
	cin >> n;
	cin >> r;
	cin >> l[r] >> ri[r];
	for (int i = 2; i <= n; i++)
	{
		char t = 0;
		cin >> t;
		cin >> l[t] >> ri[t];
	}

	dfs(r);

	return 0;
}
```
==要记住节点本身的值在二叉树中更多出现的形式就是下标，所以能够转化成下标的就一定要转化，而不是单独创建一个数组存储节点本身的值把事情搞复杂！！==
