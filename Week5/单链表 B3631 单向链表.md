# B3631 单向链表

## 题目描述

实现一个数据结构，维护一张表（最初只有一个元素 $1$）。需要支持下面的操作，其中 $x$ 和 $y$ 都是 $1$ 到 $10^6$ 范围内的正整数，且保证任何时间表中所有数字均不相同，操作数量不多于 $10^5$：

- `1 x y` ：将元素 $y$ 插入到 $x$ 后面；
- `2 x` ：询问 $x$ 后面的元素是什么。如果 $x$ 是最后一个元素，则输出 $0$；
- `3 x`：从表中删除元素 $x$ **后面的那个元素**，不改变其他元素的先后顺序。

## 输入格式

第一行一个整数 $q$ 表示操作次数。

接下来 $q$ 行，每行表示一次操作，操作具体见题目描述。

## 输出格式

对于每个操作 2，输出一个数字，用换行隔开。

## 输入输出样例 #1

### 输入 #1

```
6
1 1 99
1 99 50
1 99 75
2 99
3 75
2 1
```

### 输出 #1

```
75
99
```

#### 提交一：失败：
```cpp
#include<iostream>
using namespace std;

const int N = 1e6 + 10;
int e[N], ne[N];
int id, h, n;

int findp(int x)
{
	for (int i = ne[h]; i; i = ne[i])
	{
		if (e[i] == x)
		{
			return i;
		}
	}
}

void insert(int p, int y)
{
	e[++id] = y;
	ne[id] = ne[p];
	ne[p] = id;
}

void erase(int p)
{
	if (ne[ne[p]] != 0)
	{
		ne[p] = ne[ne[p]];
		id--;
	}
}

int main()
{
	cin >> n;
	e[++id] = 1;
	ne[id] = ne[h];
	ne[h] = id;
	while (n--)
	{
		int c;
		cin >> c;
		int x;
		cin >> x;
		int p = findp(x);
		switch (c)
		{
		case 1:
			int y;
			cin >> y;
			insert(p, y);
			break;
		case 2:
			cout << e[ne[p]] << endl;
			break;
		case 3:
			erase(p);

		}
	}
}
```

### 题解：

在上述版本中，对于特定值的地址的查询采用了遍历的方式，超过了时间限制，显然==没有使用mp哈希表进行优化==：

但是优化后超时问题消失，答案错误仍然存在；

错误1：
对于单向链表，通常删除的是后方的元素，对于mp哈希表处理时应当是：
```cpp
mp[e[ne[p]] = 0; 而不是：
mp[e[p]] = 0;
```
错误2：
对于链表的存储与顺序表模拟不同，顺序表顺序储存，每次删除元素都会n--，但是链表并非线性，==所以不应该也不能id--；==




```cpp

```