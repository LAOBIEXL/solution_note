# P1996 约瑟夫问题

## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**

## 输入格式

输入两个整数 $n,m$。

## 输出格式

输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。

## 输入输出样例 #1

### 输入 #1

```
10 3
```

### 输出 #1

```
3 6 9 2 7 1 8 5 10 4
```

### 题解：
```cpp
#include<iostream>
using namespace std;

const int N = 150;
int e[N], ne[N], h, id, n, m;

int pop(int t)
{
	int k = m - 2;
	while (k--)
	{
		t = ne[t];
	}
	cout << e[ne[t]] << " ";
	int ret = ne[ne[t]];
	ne[t] = ne[ne[t]];
	return ret;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		e[i - 1] = i;
		ne[i - 1] = i;
	}
	ne[n - 1] = 0;
	int t = 0;
	while (n--)
	{
		t = pop(t);
	}
}

```

返回下一次链表循环的起点时，需要注意==在链表删除操作中已经进行过地址的修改，这个时候返回的值不再是预期值，需要特别小心==
![[Pasted image 20251024190542.png]]

### 优化版本：
```cpp
#include<iostream>
using namespace std;

const int N = 110;
int ne[N], n, m, h;

int main()
{
	cin >> n;
	cin >> m;
	ne[h] = 1;
	//初始化循环链表：
	for (int i = 1; i < n; i++)
	{
		ne[i] = i + 1;
	}
	ne[n] = ne[ne[n]];

	//执行删除操作：
	int t = 1;
	for (int i = 1; i < m - 1; i++)
	{
		t = ne[t];
	}
	cout << ne[t] << " ";
	ne[t] = ne[ne[t]];
	int tem = n - 1;
	while (tem--)
	{
		for (int j = 1; j < m; j++)
		{
			t = ne[t];
		}
		cout << ne[t] << " ";
		ne[t] = ne[ne[t]];
	}

	/*int t = n;
	while (n--)
	{
		for (int i = 1; i < m; i++)
		{
			t = ne[t];
		}
		cout << ne[t] << " ";
		ne[t] = ne[ne[t]];
	}*/


}

```
循环链表需要手动对末尾元素的指针域进行修改~~~
![[Pasted image 20251024212259.png]]
不要向上面这么写!!!
```cpp
如下：
ne[n] = 1;
即可；
```