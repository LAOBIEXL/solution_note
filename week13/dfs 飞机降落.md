# P9241 [蓝桥杯 2023 省 B] 飞机降落
[[搜索]]
## 题目描述

$N$ 架飞机准备降落到某个只有一条跑道的机场。其中第 $i$ 架飞机在 $T_{i}$ 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 $D_{i}$ 个单位时间，即它最早可以于 $T_{i}$ 时刻开始降落，最晩可以于 $T_{i}+D_{i}$ 时刻开始降落。降落过程需要 $L_{i}$ 个单位时间。

一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。

请你判断 $N$ 架飞机是否可以全部安全降落。

## 输入格式

输入包含多组数据。

第一行包含一个整数 $T$，代表测试数据的组数。

对于每组数据，第一行包含一个整数 $N$。

以下 $N$ 行，每行包含三个整数 $T_{i},D_{i},L_{i}$。

## 输出格式

对于每组数据，输出 `YES` 或者 `NO`，代表是否可以全部安全降落。

## 输入输出样例 #1

### 输入 #1

```
2
3
0 100 10
10 10 10
0 2 20
3
0 10 20
10 10 20
20 10 20
```

### 输出 #1

```
YES
NO
```

## 说明/提示

**【样例说明】**

对于第一组数据，可以安排第 3 架飞机于 0 时刻开始降落，20 时刻完成降落。安排第 2 架飞机于 20 时刻开始降落，30 时刻完成降落。安排第 1 架飞机于 30 时刻开始降落，40 时刻完成降落。

对于第二组数据，无论如何安排，都会有飞机不能及时降落。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$N \leq 2$。

对于 $100 \%$ 的数据，$1 \leq T \leq 10$，$1 \leq N \leq 10$，$0 \leq T_{i},D_{i},L_{i} \leq 10^{5}$。 

蓝桥杯 2023 省赛 B 组 D 题。

## 分析：
这次的dfs需要有bool类型的返回值，如果要处理返回值的话， 就需要再递归函数中层层返回作用到最外层的函数上，从而实现返回；
[[小技巧]]
此外，对于需要修改的中间变量，在递归主体中也没有直接修改，而是使用了另外一个变量来传入，确保了变量之间不会互相干扰，大致的模型如下；

```cpp
bool dfs(int pos, int end)//这一层end变量会被使用但不会被修改，否则就会影响后续变量的使用；
{
	int tmp = max(t[i] , end) +l[i];
	if(dfs(pos+1 , newend)) return true //最关键的一句，将最后层成功的返回值层层传递直到最外层，并且每一次的传入都是由新创建的变量进行的而不是对end进行修改；
}
```

==总结==
对于返回正确与错误的dfs，递归出口决定了最后一层的返回，但是想要把返回值层层传递出来需要再递归的写法上有所改变；

## 易错强调：
![[Pasted image 20251216184258.png]]
小心t与数组名重复；

![[Pasted image 20251216184333.png]]
多组样例一定要注意哈希表的清空
[[错误汇总]]
![[Pasted image 20251216184406.png]]
这个地方时降落持续时间，要对应正确；

## 代码：
```cpp
#include <iostream>

#include <cstring>

using namespace std;

const int N = 15;

int n;

int t[N], d[N], l[N];

bool st[N]; // 标记路径中哪些⻜机已经摆放过

bool dfs(int pos, int end)

{

if(pos > n)

{

return true;

}

for(int i = 1; i <= n; i++)

{

if(st[i] == true) continue; // 剪枝

if(end > t[i] + d[i]) continue; // 剪枝

int newend = max(t[i], end) + l[i];

st[i] = true;

if(dfs(pos + 1, newend)) return true;

st[i] = false; // 回复现场

}

return false;

}

int main()

{

int T; cin >> T;

while(T--) // 多组测试数据的时候，⼀定要注意清空数据

{

memset(st, 0, sizeof st);

cin >> n;

for(int i = 1; i <= n; i++) cin >> t[i] >> d[i] >> l[i];

if(dfs(1, 0)) cout << "YES" << endl;

else cout << "NO" << endl;

}

return 0;

}
```