# P1434 [SHOI2002] 滑雪
[[搜索]]
## 题目描述

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：
```plain
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。

## 输入格式

输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度（两个数字之间用 $1$ 个空格间隔）。

## 输出格式

输出区域中最长滑坡的长度。

## 输入输出样例 #1

### 输入 #1

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

### 输出 #1

```
25
```

## 说明/提示

对于 $100\%$ 的数据，$1\leq R,C\leq 100$。

## 分析：
几乎的解法就是先枚举所有的起点；
找出以【i, j】为起点的最长的滑坡的长度；

剪枝：
可行性剪枝：首先排序边界情况，即不越界，并且不能向高的位置走；

并且，由于走到的点会发生重合，所以自然有对某一点的值进行存储，即记
忆化搜索；

```cpp
dx[] = {}; dy[] = {};由于这个题目没有要求顺序，而是单纯的暴力遍历，所以直接随便写四个不同的方向就行了；
```

[[小技巧]]
这种矩阵类型的dfs与之前的题目有一个区别就是递归出口不是靠某一个值或者结果来判断的，之前我们传入一个全局变量，随着递归的进行不断修改，最后在进入递归函数的时候直接判断是否需要出递归；
而本题的递归终止条件是==四个方向都走完了并且不能再走了，也就是说四个方向都被剪枝了，直接出for循环的那一刻就是递归结束的那一刻，所以递归的返回部分写在最后而不是前面==

[[错误汇总]]
- 要特别注意，坐标的修改需要备份，因为后续的几个方向的循环都是直使用形参，如果在第一个方向上修改形参，就会导致后续方向完全错误；![[Pasted image 20251218192214.png]]


## 代码：
这是以搜索的视角来写的；
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 110;
#define endl '\n'
int a[N][N];
int ret = 0;
int dx[] = { 1, -1, 0, 0 };
int dy[] = { 0, 0, 1, -1 };
int r, c;
int path = 1;


void dfs(int x, int y)
{
    int flag = 1;
    for (int k = 0; k < 4; k++)
    {
        int h = a[x][y];
        int x1 = x + dx[k];
        int y1 = y + dy[k];
        //剪枝;
        if (x1 < 0 || y1 < 0 || x1 >= r || y1 >= c) continue;
        if (a[x1][y1] > h) continue;
        path++;
        dfs(x1, y1);
        path--;
        flag = 0;
    }
    if (flag)
    {
        ret = max(ret, path);
    }
    return;
    
}


void solve()
{
    //不要忘记清空数组；
   
    cin >> r >> c;
    for (int i = 0; i < r; i++)
    {
        for (int j = 0; j < c; j++)
        {
            cin >> a[i][j];
        }
    }
    for (int i = 0; i < r; i++)
    {
        for (int j = 0; j < c; j++)
        {
            dfs(i, j);
        }
    }
    cout << ret << endl;
}

signed main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
 
        solve();
}
```
但是记忆化搜索就要抱着状态表示来写，明确每一部分发挥的作用；

```cpp
#include <iostream>

using namespace std;

const int N = 110;

int n, m;

int a[N][N];

int f[N][N]; // 备忘录

int dx[] = {0, 0, 1, -1};

int dy[] = {1, -1, 0, 0};

int dfs(int i, int j)

{

if(f[i][j]) return f[i][j];

int len = 1;

// 上下左右四个⽅向搜

for(int k = 0; k < 4; k++)

{

int x = i + dx[k], y = j + dy[k];

if(x < 1 || x > n || y < 1 || y > m) continue;

if(a[i][j] <= a[x][y]) continue;

len = max(dfs(x, y) + 1, len);

}

return f[i][j] = len;

}

int main()

{

cin >> n >> m;

for(int i = 1; i <= n; i++)

for(int j = 1; j <= m; j++)

cin >> a[i][j];

int ret = 1;

for(int i = 1; i <= n; i++)

for(int j = 1; j <= m; j++)

ret = max(ret, dfs(i, j));

cout << ret << endl;

return 0;

}
```