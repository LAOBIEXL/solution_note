# P10483 小猫爬山
[[搜索]]
## 题目描述

Freda 和 rainbow 饲养了 $N(N\le 18)$ 只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了

Freda 和 rainbow 只好花钱让它们坐索道下山。索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1,C_2,\dots C_N$。当然，每辆缆车上的小猫的重量之和不能超过 $W(1\le C_i,W \le 10^8)$。每租用一辆缆车，Freda 和 rainbow 就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？

## 输入格式

第一行包含两个用空格隔开的整数，$N$ 和 $W$。
接下来 $N$ 行每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。

## 输出格式

输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。

## 输入输出样例 #1

### 输入 #1

```
5 1996
1
2
1994
12
29
```

### 输出 #1

```
2
```

## 分析：
![[1766020338286.png]]
对于每一个被等待分配的猫，都进行一次决策，判断是需要将其放在已经存在的车上，还是单独new一个新的车，这种类型的决策会产生决策树；

剪枝：
1.可行性剪枝：
当某一个分支超过最大载重，就进行剪枝；
2.最优性剪枝：
所求的是最小的缆车的数量，利用目前已经搜索到的来优化剪枝；
3.优化搜索顺序：
优先考虑放在已有车辆的分支，否则最优化剪枝的作用会被大大削弱；

并且从大到小来安排小喵，因为存在可行性剪枝，当车子里已经有相对较大的小喵时候，就更容易触发第一类剪枝；

## 代码：
```cpp
#include <iostream>

#include <algorithm>

using namespace std;

const int N = 20;

int n, w;

int c[N]; // ⼩猫的信息

int cnt; // 当前⽤了多少⻋

int s[N]; // 每⼀辆⻋⽬前的总重

int ret = N; // 最优解

bool cmp(int a, int b)

{

return a > b;

}

void dfs(int pos)

{

// 策略⼆：最优性剪枝

if(cnt >= ret) return;

if(pos > n)

{

ret = cnt;

return;
}

// 策略三：优化搜索顺序

// 先安排在已有的⻋辆上

for(int i = 1; i <= cnt; i++)

{

// 策略⼀：可⾏性剪枝

if(s[i] + c[pos] > w) continue;

s[i] += c[pos];

dfs(pos + 1);

s[i] -= c[pos]; // 恢复现场

}

// 重开⼀辆⻋

cnt++;

s[cnt] = c[pos];

dfs(pos + 1);

// 恢复现场

s[cnt] = 0;

cnt--;

}

int main()

{

cin >> n >> w;

for(int i = 1; i <= n; i++) cin >> c[i];

// 策略三：优化搜索顺序

sort(c + 1, c + 1 + n, cmp);

dfs(1);

cout << ret << endl;

return 0;

}
```