# P2085 最小函数值

## 题目描述

有 $n$ 个函数，分别为 $F_1,F_2,\dots,F_n$。定义 $F_i(x)=A_ix^2+B_ix+C_i(x\in\mathbb N*)$。给定这些 $A_i$、$B_i$ 和 $C_i$，请求出所有函数的所有函数值中最小的 $m$ 个（如有重复的要输出多个）。

## 输入格式

第一行输入两个正整数 $n$ 和 $m$。  

以下 $n$ 行每行三个正整数，其中第 $i$ 行的三个数分别为 $A_i$、$B_i$ 和 $C_i$。

## 输出格式

输出将这 $n$ 个函数所有可以生成的函数值排序后的前 $m$ 个元素。这 $m$ 个数应该输出到一行，用空格隔开。

## 输入输出样例 #1

### 输入 #1

```
3 10
4 5 3
3 4 5
1 7 1
```

### 输出 #1

```
9 12 12 19 25 29 31 44 45 54
```

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m\le10000$，$1 \leq A_i\le10$,
$0 \leq B_i\le100$,
$0 \leq C_i\le10^4$。

### 思路：

可以很轻易的发现，给出的函数均是单调递增，那么这个问题就是将各个单调递增的函数归并处最小的第m个的过程；

### 题解：
```cpp

#include<iostream>
#include<queue>
using namespace std;

struct Node {
	int num;
	int e;
	int x;

	bool operator <(const Node& z) const
	{
		//生成小根堆，所以大元素下坠
		return e > z.e;
	}
};

const int N = 1e4 + 10;
int a[N], b[N], c[N];
int n, m;

int value(int num, int x)
{
	return a[num] * x * x + b[num] * x + c[num];
}

//创建存储结构体的堆：
priority_queue<Node> heap;


int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i] >> b[i] >> c[i];
	}
	//初始化函数完成；

	//初始化堆；
	for (int i = 1; i <= n; i++)
	{
		heap.push({ i, value(i, 1), 1 });
	}
	//初始化完成；

	//选取结果：
	while (m--)
	{
		Node tem = heap.top();
		cout << tem.e << " ";
		heap.pop();
		heap.push({ tem.num, value(tem.num, tem.x + 1), tem.x + 1 });
	}


}
```

### 重点：
1. 对于结构体的比较运算符重载；
2. 如何在优先级队列的容器中同时传入多个信息通过结构体；
