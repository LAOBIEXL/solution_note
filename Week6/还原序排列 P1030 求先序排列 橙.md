# P1030 [NOIP 2001 普及组] 求先序排列

## 题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。

## 输入格式

共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。

## 输出格式

共一行一个字符串，表示一棵二叉树的先序。

## 输入输出样例 #1

### 输入 #1

```
BADC
BDCA
```

### 输出 #1

```
ABCD
```

## 说明/提示

**【题目来源】**

NOIP 2001 普及组第三题

### 思路：
题目给出了后序排列和中序排列，由后序排列的最后一个元素可以知道整个树的根节点是什么，然后在中序排列中寻找这个根节点的位置，由于是中序排列，所以根节点的左右分别是左右子树的中序排列，而后序排列对应宽度的位置也是对应子树的后序排列，由此进行递归；
![[Pasted image 20251031155423.png]]
由于所求的是先序序列，所以一旦找到根节点，就进行输出，然后再先对左子树执行这一过程，最后对右子树执行这一过程即可；

在具体的代码执行阶段，需要向递归函数传入左右子树串的范围，如果是其他形式很不方便，==最优解就是传入左右子串区间的两个指针==，即中序遍历的头和尾指针，后序遍历的头和尾指针；

改出条件：
由模拟可知，边界情况是区间内只有一个元素，所以只需要全包区间指针的大小关系相反时退出函数即可

### 题解：
```cpp
//求排列

#include<iostream>
using namespace std;

string a;

string b;

void dfs(int p1, int p2, int p3, int p4)
{
	if (p1 > p2 || p3 > p4) return;
	char root = b[p4];
	int t = p1;
	while (a[t] != root) t++;
	cout << root;
	dfs(p1, t - 1, p3, p3 + t - 1 - p1);
	dfs(t + 1, p2, p3 + t - p1, p4 - 1);
} 


int main()
{
	cin >> a >> b;
	int p1 = 0, p3 = 0;
	int p2 = a.size() - 1, p4 = b.size() - 1;

	dfs(p1, p2, p3, p4);


}
```