# P3884 [JLOI2009] 二叉树问题

## 题目描述

如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：

- 深度：$4$
- 宽度：$4$
- 结点 8 和 6 之间的距离：$8$
- 结点 7 和 6 之间的距离：$3$

其中宽度表示二叉树上同一层最多的结点个数，节点 $u, v$ 之间的距离表示从 $u$ 到 $v$ 的最短有向路径上向根节点的边数的两倍加上向叶节点的边数。

![](https://cdn.luogu.com.cn/upload/pic/6843.png)

给定一颗以 1 号结点为根的二叉树，请求出其深度、宽度和两个指定节点 $x, y$ 之间的距离。

## 输入格式

第一行是一个整数，表示树的结点个数 $n$。  
接下来 $n - 1$ 行，每行两个整数 $u, v$，表示树上存在一条连接 $u, v$ 的边。  
最后一行有两个整数 $x, y$，表示求 $x, y$ 之间的距离。

## 输出格式

输出三行，每行一个整数，依次表示二叉树的深度、宽度和 $x, y$ 之间的距离。

## 输入输出样例 #1

### 输入 #1

```
10                                
1 2                            
1 3                            
2 4
2 5
3 6
3 7
5 8
5 9
6 10
8 6
```

### 输出 #1

```
4
4
8
```

## 说明/提示

对于全部的测试点，保证 $1 \leq u, v, x, y \leq n \leq 100$，且给出的是一棵树。保证 $u$ 是 $v$ 的父结点。

### 思路：
首先，这个题目给出树的方式是一条边上连接的两个数，并且父子关系明确，也就是说我们不知道谁是左孩子谁是右孩子，并且这一点在这一题中也不重要，所以这题使用vector数组来存储；

对于深度，使用dfs的方法，对于宽度，使用bfs的方法，对于距离，则使用哈希表记录父节点的信息；

关于距离的计算：
首先，需要快速找到起点元素，为了不进行遍历，使用哈希表，建立一个父节点表，即以对应节点的值作为下标，快速找到对应节点的父节点，并且一直重复操作直到根节点；

每次进行回溯，就在距离数组标记各个节点到出发节点的距离，回溯到根节点后，再对终点节点进行回溯，并且判断这一次回溯的父节点作为下标的dist数组中是否有值，如果有值，则代表这个节点是两者的共同节点，那么就可以计算距离；

### 题解：
```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;

const int N = 110;
vector<int> edges[N];

//父节点数组
int fa[N];
//距离数组；
int dist[N];

int dfs(int root)
{
	//改出条件
	//由于vector存储的数与二叉树不同，不存在的节点不会为零，所以遍历为空时会自动返回，不需要特地写改出条件；


	//求出子树中最大的深度 
	int ma = 0;
	for (auto e : edges[root])
	{
		ma = max(ma,dfs(e));//找出最大值的快捷；
	}
	return ma + 1;
}

int bfs(int r)
{
	queue<int> q;
	q.push(r);
	int ret = 0;
	while (q.size())
	{
		int tem = q.size();//记录每一层的数量，用来进行层清空的计数
		ret = max(tem, ret);//选出最大层数；
		while (tem--)
		{
			int t = q.front();
			q.pop();
			for (auto h : edges[t])
			{
				q.push(h);
			}
		}
	}
	return ret;
}



int main()
{
	//存储
	int n;
	cin >> n;
	for (int i = 1; i < n; i++)
	{
		int a, b;
		cin >> a >> b;
		edges[a].push_back(b);
		fa[b] = a;
	}
	cout << dfs(1) << endl;
	cout << bfs(1) << endl;

	int t1, t2;
	cin >> t1 >> t2;
	
	int p = t1;
	
	while (p != 1)
	{
		dist[fa[p]] = dist[p] + 1;
		//每一次回溯距离加一；
		p = fa[p];
	}

	int p2 = t2;
	int count = 0;//专门记录终止节点的距离
	while (p2 != 1 && !dist[p2])
	{
		p2 = fa[p2];
		count++;
	}

	cout << count + 2 * dist[p2] << endl;


}
```