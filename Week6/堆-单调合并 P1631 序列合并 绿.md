# P1631 序列合并

## 题目描述

有两个长度为 $N$ 的**单调不降**序列 $A,B$，在 $A,B$ 中各取一个数相加可以得到 $N^2$ 个和，求这 $N^2$ 个和中最小的 $N$ 个。

## 输入格式

第一行一个正整数 $N$；

第二行 $N$ 个整数 $A_{1\dots N}$。

第三行 $N$ 个整数 $B_{1\dots N}$。

## 输出格式

一行 $N$ 个整数，从小到大表示这 $N$ 个最小的和。

## 输入输出样例 #1

### 输入 #1

```
3
2 6 6
1 4 8
```

### 输出 #1

```
3 6 7
```

## 说明/提示

对于 $50\%$ 的数据，$N \le 10^3$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le a_i,b_i \le 10^9$。


### 题解：
```cpp
#include<iostream>
#include<queue>
using namespace std;

const int N = 1e5 + 10;

int a[N], b[N];
int n;

struct Node {
	int num;//a数组下标；
	int k; //b数组对应的下标；

	int e;//值

	bool operator <(const Node& x) const
	{
		return e > x.e;
	}
};

priority_queue<Node> heap;


int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> b[i];
	}
	//初始化堆；

	for (int i = 1; i <= n ; i++)
	{
		heap.push({ i, 1, a[i] + b[1] });
	}
	//初始化完成；

	//开始循环输出结果：

	while (n--)
	{
		Node tem = heap.top();
		heap.pop();
		cout << tem.e << " ";
		heap.push({ tem.num, tem.k + 1, a[tem.num] + b[tem.k + 1] });
	}


	return 0;
}
```