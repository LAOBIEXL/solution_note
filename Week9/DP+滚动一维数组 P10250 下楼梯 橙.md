# P10250 [GESP样题 六级] 下楼梯

## 题目描述

顽皮的小明发现，下楼梯时每步可以走 $1$ 个台阶、$2$ 个台阶或 $3$ 个台阶。现在一共有 $N$ 个台阶，你能帮小明算算有多少种方案吗？

## 输入格式

输入一行，包含一个整数 $N$。

## 输出格式

输出一行一个整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
4
```

### 输出 #1

```
7
```

## 输入输出样例 #2

### 输入 #2

```
10
```

### 输出 #2

```
274
```

## 说明/提示

对全部的测试点，保证 $1 \leq N \leq 60$。

# 分析：

1. 状态表示：
```cpp
f[i] 表示有i个台阶的时候，一共有多少中方案；
```

2. 推导状态转移方程：
经验：==根据"最后一步"划分情况，并且推导状态转移方程：==

从i-1，i-2 , i-3 跳跃到第i号；
```cpp
状态转移方程：
f[i] = f[i-1] + f[i-2] + f[i-3];
```

3. 初始化：
意义：
- 保证填表是正确的；
- 保证填表的时候不越界；

首先：要确定从哪一位开始for循环，要避免在循环中越界；
其次：dp表中零下标的值有的时候不好确定，如果一定要确定，可以通过后面的值再结合状态转移方程反推；

## 代码：
```cpp
#include<iostream>
using namespace std;

const int N = 70;
long long f[N]; //f[i]的状态表示为有i个台阶的时候，一共有多少种方案；

int main()
{
	int n;
	cin >> n;
	f[0] = 1;
	f[1] = 1;
	f[2] = 2;
	for (int i = 3; i <= n; i++)
	{
		f[i] = f[i - 1] + f[i - 2] + f[i - 3];
	}

	cout << f[n] << endl;




	return 0;
}
```

### 空间优化：滚动数组：
```cpp
#include<iostream>
using namespace std;

long long a, b, c, t;

int main()
{
	int n;
	cin >> n;
	a = 1; b = 1; c = 2;
	for (int i = 3; i <= n; i++)
	{
		t = a + b + c;
		a = b;
		b = c;
		c = t;
	}
	//这里需要小心如果n为1，2的话，是不会进入循环的，但是有由于本来就是输出c的值，所以只有n=1需要特殊说明；

	if (n == 1) cout << b;
	else cout << c;
}
```