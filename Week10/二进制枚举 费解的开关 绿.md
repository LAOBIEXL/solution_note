# P10449 费解的开关

## 题目描述

你玩过“拉灯”游戏吗？

$25$ 盏灯排成一个 $5 \times 5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯==上下左右相邻==的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

下面这种状态

    10111
    01101
    10111
    10000
    11011


在改变了最左上角的灯的状态后将变成：

    01111
    11101
    10111
    10000
    11011


再改变它正中间的灯后状态将变成：

    01111
    11001
    11001
    10100
    11011


给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。

## 输入格式

第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。

以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

## 输出格式

一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `-1`。

## 输入输出样例 #1

### 输入 #1

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

### 输出 #1

```
3
2
-1
```

## 说明/提示

测试数据满足 $0 < n \le 500$。

## 分析：
1. 首先，如图，通过枚举第一行来判断和计算：

重点：
- 对于题目给出的==灯的亮暗情况，需要反转存储==，这样便于最后直接判断是否等于零直接判断是不是全亮；
- 在存储输入的时候，要注意第一输入的数是二进制的第一位，也就是说
输入  0 1 1 0 1 0 1 ；
在以二进制存储的时候是反过来看的  实际上存入的数应该是 1 0 1 0 1 1 0；
这样做的目的是为了后续的操作；

![[1764336182455.png]]

2. 二进制枚举的难点和优点不仅仅在于存储，更在于进行位运算的操作十分便捷，如下面，需要将某一个位置放反，只需要按位异或；

![[1764336704585.png]]

3. ==需要特别注意，当在最高位进行右移动并且按位异或的时候，会把不存在的一位置1，这种情况特别隐蔽，因为是通过二进制的一个数字存储，所以不会有越界的提示，一定要小小心边界情况；解决的办法如下：==

![[1764337297778.png]]

4. 在循环中，下一行的操作就是第一行的结果；

![[1764337557753.png]]


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 0;
#define endl '\n'

int ret = 10000;

int main()
{
	int T;
	cin >> T;
	while (T--)
	{
		int a[5] = {};
		int t[5] = {};
		for (int i = 0; i < 5; i++)
		{
			for (int j = 0; j < 5; j++)
			{
				char t;
				cin >> t;
				if (t == '0') a[i] = a[i] |= (1 << j);
			}
		}
		int ret = 0x3f3f3f3f;
		for (int st = 0; st < (1 << 5); st++)
		{
			memcpy(t, a, sizeof(a));
			int push = st; // 要养成操作变量和循环变量互相区分和备份的习惯，保证源数据的正确性；
			int cnt = 0;
			for (int i = 0; i < 5; i++)
			{
				t[i] = push ^ t[i] ^ (push >> 1) ^ (push << 1);
				t[i] = t[i] & ((1 << 5) - 1);//防止位溢出；

				int tmp = push;
				while (tmp)
				{
					cnt++;
					tmp &= tmp - 1;
				}

				//对第一行的；
				t[i + 1] = t[i + 1] ^ push;
				push = t[i];
			}
			if (t[4] == 0) ret = min(ret, cnt);
		}
		if (ret > 6) cout << -1 << endl;
		else cout << ret << endl;
	}
}
```