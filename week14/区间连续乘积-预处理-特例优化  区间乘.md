[[预处理]]
![[Pasted image 20251224184321.png]]
[[滑动窗口：]]
## 分析：
这道题目显然可以使用滑动窗口做，但是一定会超时；不过需要提醒的是出窗口后不要忘记判断；
```cpp
错误代码：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e5 + 10;
#define endl '\n'
int a[N];
int quest[N];

void solve()
{
    //不要忘记清空数组；
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for (int i = 0; i < q; i++)
    {
        cin >> quest[i];
    }
    for(int i = 0; i < q; i++)
    {
        int left = 1, right = 1;
        ull sum = 1;
        int flag = 1;
        while (right <= n)
        {
            sum *= a[right];
            if (sum == quest[i])
            {
                flag = 0;
                cout << "YES" << endl;
                break;
            }
            while (sum > quest[i])
            {
                sum = sum / a[left];
                left++;
            }
            right++;
        }
        if (flag) cout << "NO" << endl;

    }
   
    


}

signed main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int TestCase = 1;
    cin >> TestCase;
    while (TestCase--)
        solve();
}
```
![[Pasted image 20251224190136.png]]
[[错误汇总]]

正确：![[Pasted image 20251224190237.png]]

所以最后使用的是预处理所有乘积的方法：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e5 + 10;
#define endl '\n'

int quest[N];
int a[N];

void solve()
{
    unordered_set<ull> mp;
    //不要忘记清空数组；
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++)
    {
        ull sum = 1;
        int k = i;
        while (sum <= 1e9 && k <= n)
        {
            sum *= a[k];
            mp.insert(sum);
            k++;
        }
    }
    for (int i = 0; i < q; i++)
    {
        cin >> quest[i];
    }
    for (int i = 0; i < q; i++)
    {
        int tmp = quest[i];
        if (mp.count(tmp))
        {
            cout << "yes" << endl;
        }
        else
        {
            cout << "no" << endl;
        }
    }
}

signed main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int TestCase = 1;
    cin >> TestCase;
    while (TestCase--)
        solve();
}
```
但是这种处理任然会超时，因为对于特殊序列（全是1)的序列，在预处理时会大大增加循环次数，所以要从非一的位置开始循环；
[[小技巧]]
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e5 + 10;
#define endl '\n'

int quest[N];
int a[N];

void solve()
{
    unordered_set<ull> mp;
    //不要忘记清空数组；
    int n, q;
    int flag1 = 0;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++)
    {
        if(a[i] == 1) 
        {
            flag1 = 1;
            continue;
        }
        ull sum = 1;
        int k = i;
        while (sum <= 1e9 && k <= n)
        {
            sum *= a[k];
            mp.insert(sum);
            k++;
        }
    }
    for (int i = 0; i < q; i++)
    {
        cin >> quest[i];
    }
    for (int i = 0; i < q; i++)
    {
   
        int tmp = quest[i];
        if(tmp == 1 && flag1) 
        {
            cout << "yes" <<endl;
            continue;
        }
        if (mp.count(tmp))
        {
            cout << "yes" << endl;
        }
        else
        {
            cout << "no" << endl;
        }
    }
}

signed main()
{
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    int TestCase = 1;
    cin >> TestCase;
    while (TestCase--)
        solve();
}
```