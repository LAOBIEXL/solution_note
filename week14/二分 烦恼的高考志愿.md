# P1678 烦恼的高考志愿
[[二分]]
## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。

## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。

## 输入格式

第一行读入两个整数 $m,n$。

第二行共有 $m$ 个数，表示 $m$ 个学校的预计录取分数。

第三行有 $n$ 个数，表示 $n$ 个学生的估分成绩。

## 输出格式

输出一行，为最小的不满度之和。

## 输入输出样例 #1

### 输入 #1

```
4 3
513 598 567 689
500 600 550
```

### 输出 #1

```
32
```

## 说明/提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq10^3$，估分和录取线 $\leq10^4$；

对于 $100\%$ 的数据，$1\leq n,m\leq10^5$，估分和录取线 $\leq 10^6$ 且均为非负整数。

## 分析：
[[错误汇总]]
注意，upper_bound(不能寻找位于排序最后的元素)，lower_bound()可以，但是手写的二分算法可以寻找最靠近的位置，比如你最大是9，但是我二分查找10，无论是哪一种模版，都会返回9的下标，这个就是最接近的数，但是lower_bound()不行，你只能寻找存在的数，不能够超出范围的寻找；[[小技巧]]
==或者换句话说，lower_bound和upper_bound确实只会找到这个数后面的数，如果你最小的元素是3，你查找1还是能返回三的指针的；==

第二，sort如果从一开始，要写到n + 1;

==原则上，左右护法缺一不可，并且要时刻小心sort是否把全部数组都排序了==

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e5 + 10;
int a[N], b[N];

signed main()
{
    int m, n;
    cin >> m >> n;
    for (int i = 1; i <= m; i++)
    {
        cin >> a[i];
    }
    a[m + 1] = 0x3f3f3f3f;
    m++;
    a[0] = -200000000;
    sort(a, a + m + 1);
    ll ret = 0;
    for (int i = 0; i < n; i++)
    {
        int t = 0;
        cin >> t;

        int* pos1 = lower_bound(a, a + m + 1, t);

        int* pos2 = pos1 - 1;
        ret += min(abs(*pos1 - t), abs(*pos2 - t));
    }
    cout << ret << endl;
}
```