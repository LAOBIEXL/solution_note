 ![[Pasted image 20251225154807.png]]
[[二分]]

## 分析：
第一：
所给出的序列是不严格递增序列，所以，需要判断的==x和y可能有多个，所以对于x，需要找到第一个出现的x， 对于y，需要找到最后一个出现的y，所以二分查找两个值时，使用的模版是不同的；==
第二：[[小技巧]][[错误汇总]]
对于不存在的情况，二分的接近给出目标的特性能够很好地解决，但是当两个范围均不存在时，就会出现误判，所以要判断给出的区间是否合法；
![[Pasted image 20251225155142.png]]

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e5 + 10;
#define endl '\n'
int a[N];


signed main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> a[i];
    }
    int q;
    cin >> q;
    for (int i = 0; i < q; i++)
    {
        int x, y;
        cin >> x >> y;
        if(x > a[n - 1] || y < a[0] )
        {
            cout << 0 << endl;
            continue;
        }
        
        int left = 0, right = n - 1;
        while (left < right)
        {
            int mid = (left + right) / 2;
            if (a[mid] >= x)
            {
                right = mid;
            }
            else
            {
                left = mid + 1;
            }
        }
        int pos1 = left;
   
        left = 0, right = n - 1;
        while (left < right)
        {
            int mid = (left + right + 1) / 2;
            if (a[mid] <= y)
            {
                left = mid;
            }
            else
            {
                right = mid - 1;
            }
        }
        int pos2 = left;
        
     
        cout << pos2 - pos1 + 1 << endl;
    }
}
```