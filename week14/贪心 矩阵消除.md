![[Pasted image 20251226221041.png]]
![[Pasted image 20251226222135.png]]

## 分析：
原则上可以对矩阵的每一行每一列都计算求和，然后排序，但是由于列或行被删除之后，显然会影响之后的选择；所以这个题目单纯采用简单贪心策略是行不通的；
1. 这种贪心的选择不满足无后效性，前面选择最大的，后面可以选择的就少了；
2. 注意数据范围，非常小；

首先写搜索或者二进制枚举，枚举所有的列的可能选择方式，再根据选择好列的方式选择剩下的行，选择行的时候就可以使用贪心了；

[[错误汇总]]
1. 只考虑了选择的列数不超过k，没有排除选择的列数过少时导致 choo - k 超出行数范围的情况；

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 30;
ll a[N][N];
ll fake_a[N][N];

signed main()
{	
	ll n, m, k;
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			cin >> a[i][j];
		}
	}
	
	
	ll ret = 0;
	for (ll st = 0; st < (1 << m); st++)
	{
		memcpy(fake_a, a, sizeof(a));
		ll tmp = 0;
		ll pos = 0;
		ll k_se = st;
		ll choo = 0;
		while (k_se)
		{
			if (k_se & 1)
			{
				for (int i = 0; i < n; i++)
				{
					tmp += fake_a[i][pos];
					fake_a[i][pos] = 0;
					
				}
				choo++;
			}
			pos++;
			k_se >>= 1;
		}
		if (choo > k) continue;

		//贪心；
		vector<ll> rows;
		
		for (int i = 0; i< n; i++)
		{
			ll t = 0;
			for (int j = 0; j < m; j++)
			{
				t += fake_a[i][j];
			}
			rows.push_back(t);
		}
		sort(rows.rbegin(), rows.rend());
		for (int i = 0; i < min(n, k - choo); i++)
		{
			tmp += rows[i];
		}
		ret = max(ret, tmp);
	}
	cout << ret << endl;
}
```