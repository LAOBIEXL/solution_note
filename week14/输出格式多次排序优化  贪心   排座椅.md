# P1056 [NOIP 2008 普及组] 排座椅

## 题目描述
[[贪心]]
上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。

同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。

## 输入格式

第一行，有 $5$ 个用空格隔开的整数，分别是 $M,N,K,L,D(2 \le N,M \le 1000,0 \le K<M,0 \le L<N,0\le D \le 2000)$。

接下来的 $D$ 行，每行有 $4$ 个用空格隔开的整数。第 $i$ 行的 $4$ 个整数 $X_i,Y_i,P_i,Q_i$，表示坐在位置 $(X_i,Y_i)$ 与 $(P_i,Q_i)$ 的两个同学会交头接耳（输入保证他们前后相邻或者左右相邻）。

输入数据保证最优方案的唯一性。

## 输出格式

共两行。  
第一行包含 $K$ 个整数 $a_1,a_2,\ldots,a_K$，表示第 $a_1$ 行和 $a_1+1$ 行之间、第 $a_2$ 行和 $a_2+1$ 行之间、…、第 $a_K$ 行和第 $a_K+1$ 行之间要开辟通道，其中 $a_i< a_{i+1}$，每两个整数之间用空格隔开（行尾没有空格）。

第二行包含 $L$ 个整数 $b_1,b_2,\ldots,b_L$，表示第 $b_1$ 列和 $b_1+1$ 列之间、第 $b_2$ 列和 $b_2+1$ 列之间、…、第 $b_L$ 列和第 $b_L+1$ 列之间要开辟通道，其中$b_i< b_{i+1}$，每两个整数之间用空格隔开（列尾没有空格）。

## 输入输出样例 #1

### 输入 #1

```
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
```

### 输出 #1

```
2
2 4
```

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

上图中用符号\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。

2008 年普及组第二题


## 分析：
这题其实难点在于输出格式；

## 代码：
```cpp
未优化版本：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e3 + 10;
#define endl '\n'

struct node {
	ll index;
	ll num;
}k[N], l[N];

bool cmp(const node& a, const node& b)
{
	return a.num > b.num;
}

signed main()
{
	int M, N, K, L, D;
	cin >> M >> N >> K >> L >> D;
	for (int i = 1; i <= D; i++)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		if (x1 == x2)
		{
			int y_min = min(y1, y2);
			int y_max = max(y1, y2);
			l[y_min].index = y_min;
			l[y_min].num++;
		}
		else if (y1 == y2)
		{
			int x_min = min(x1, x2);
			int y_max = max(x1, x2);
			k[x_min].index = x_min;
			k[x_min].num++;
		}
	}
	sort(k, k + N, cmp);
	sort(l, l + N, cmp);
	unordered_set<int> a;
	unordered_set<int> b;
	ll max_index_k = 0;
	ll max_index_l = 0;
	for (int i = 0; i < K; i++)
	{
		max_index_k = max(k[i].index, max_index_k);
		a.insert(k[i].index);
	}
	for (int j = 0; j < L; j++)
	{
		max_index_l = max(l[j].index, max_index_l);
		b.insert(l[j].index);
	}
	for (int i = 1; i < max_index_k; i++)
	{
		if (a.count(i)) cout << i << " ";
	}
	cout << max_index_k << endl;
	for (int i = 1; i < max_index_l; i++)
	{
		if (b.count(i)) cout << i << " ";
	}
	cout << max_index_l << endl;
}
```

## 优化：
[[小技巧]]
对于需要多次排序的，使用结构体可以方便自定义排序，并且思路是==首先对全范围以变量一为比较对象进行排序，然后再在需要输出的范围以变量二进行排序即可；
![[Pasted image 20251226220949.png]]

```cpp
优化点一：结构体初始化：
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e3 + 10;
#define endl '\n'

struct node {
	ll index;
	ll num;
}k[N], l[N];

bool cmp(const node& a, const node& b)
{
	return a.num > b.num;
}

bool cmp2(node& a, node& b)
{
	return a.index < b.index;
}

signed main()
{
	int M, N, K, L, D;
	cin >> M >> N >> K >> L >> D;
	for (int i = 1; i <= M; i++)
	{
		k[i].index = i;
	}
	for (int i = 1; i <= N; i++)
	{
		l[i].index = i;
	}
	for (int i = 1; i <= D; i++)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		if (x1 == x2)
		{
			int y_min = min(y1, y2);
			int y_max = max(y1, y2);
	/*		l[y_min].index = y_min;*/
			l[y_min].num++;
		}
		else if (y1 == y2)
		{
			int x_min = min(x1, x2);
			int y_max = max(x1, x2);
	/*		k[x_min].index = x_min;*/
			k[x_min].num++;
		}
	}
	sort(k, k + M, cmp);
	sort(l, l + N, cmp);

	sort(k, k + K, cmp2);
	sort(l, l + L, cmp2);
	for (int i = 0; i < K; i++)
	{
		cout << k[i].index << " ";
	}
	cout << endl;
	for (int j = 0; j < L; j++)
	{
		cout << l[j].index << " ";
	}
	cout << endl;


	//unordered_set<int> a;
	//unordered_set<int> b;
	//ll max_index_k = 0;
	//ll max_index_l = 0;
	/*for (int i = 0; i < K; i++)
	{
		max_index_k = max(k[i].index, max_index_k);
		a.insert(k[i].index);
	}
	for (int j = 0; j < L; j++)
	{
		max_index_l = max(l[j].index, max_index_l);
		b.insert(l[j].index);
	}
	for (int i = 1; i < max_index_k; i++)
	{
		if (a.count(i)) cout << i << " ";
	}
	cout << max_index_k << endl;
	for (int i = 1; i < max_index_l; i++)
	{
		if (b.count(i)) cout << i << " ";
	}
	cout << max_index_l << endl;*/



}
```