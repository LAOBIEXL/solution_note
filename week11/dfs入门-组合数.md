# P10448 组合型枚举
[[搜索]]
## 题目描述

从 $1 \sim n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。

## 输入格式

两个整数 $n, m$ ,在同一行用空格隔开。

## 输出格式

按照从小到大的顺序输出所有方案，每行 $1$ 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

## 输入输出样例 #1

### 输入 #1

```
5 3
```

### 输出 #1

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5
```

## 说明/提示

对于所有测试数据满足 $0 \le m \le n$ ,  $ n+(n-m) \le 25 $。

## 分析：
组合数dfs的关键就是每一次决策时选择了的数不能再次被选择；
```cpp
例如：
选择数123456中选择4个数；
如果选择了1 4 后面两个数就不能选择1 - 4之间的所以数，因为决策是按顺序决策的，1 2  ， 1 3 都在前出现过了，组合数不能选择重复的（排列数可以）；
```
![[Pasted image 20251207095353.png]]
## 代码：
```cpp
#include <iostream>

#include <vector>

using namespace std;

int n, m; 

vector<int> path;

// path.size();

void dfs(int begin)//只需要传入下一次遍历的开始位置即可；

{

if(path.size() == m)

{

for(auto x : path) cout << x << " ";

cout << endl;

return;

}

for(int i = begin; i <= n; i++)

{

path.push_back(i);

dfs(i + 1);

path.pop_back(); // 清空现场

}

}

int main()

{

cin >> n >> m;

dfs(1);

return 0;

}
```