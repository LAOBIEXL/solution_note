# P2234 [HNOI2002] 营业额统计
[[set-multiset & map-multimap]]
## 题目描述

Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。

Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。

而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。

我们定义，一天的最小波动值 = $\min\{|\text{该天以前某一天的营业额}-\text{该天营业额}|\}$。

特别地，第一天的最小波动值为第一天的营业额。

## 输入格式

第一行为正整数 $n$（$n \leq 32767$） ，表示该公司从成立一直到现在的天数，接下来的 $n$ 行每行有一个整数 $a_i$（$|a_i| \leq 10^6$) ，表示第 $i$ 天公司的营业额，可能存在负数。

## 输出格式

输出一个整数，即每一天最小波动值的和，保证结果小于 $2^{31}$。

## 输入输出样例 #1

### 输入 #1

```
6
5
1
2
5
4
6
```

### 输出 #1

```
12
```

## 说明/提示

结果说明：$5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$
## 分析：
```cpp
解题的关键是每一次要累加的值就是这个值与它前面所有值中最靠近它的值

使用的工具是红黑树：
set

最靠近的值有两种可能性 ：
要么是大于i的最小值；
要么是小于i的最大值；

可以通过
set::iterator p2 = set.lower_bound(i);
set::iterator p1 = p2--;
```
然后很遗憾的告诉你上面的是错的；
因为p2--会改变p2;
```cpp
auto p2 = set.lower_bound(i);
这里，填在括号里数不要求一定出现在红黑树中；
auto tmp = p2;
auto p1 = --tmp;
int ret = (fabs(*p2 - i) < fabs(*p1 - i)) ? *p2 : *p1;
```

==第二个非常重要的点==
寻找最靠近的值的时候对迭代器进行操作的时候可能会导致越界访问；
```cpp
使用左右护法：
const int N = 1e7;

int INF = 1e8;
st.insert(INF);
st.insert(-INF);
这样可以防止越界
```

## 代码：
```cpp
#include <iostream>

#include <set>

using namespace std;

const int INF = 1e7 + 10;

int n;

set<int> mp; // 存储 i 天之前的营业额

int main()

{

cin >> n;

int ret; cin >> ret;

mp.insert(ret);

// 左右护法 - 防⽌越界访问

mp.insert(-INF); mp.insert(INF);

for(int i = 2; i <= n; i++)

{

int x; cin >> x;

// 找出距离 x 最近的那⼀个

auto it = mp.lower_bound(x);

auto tmp = it;

tmp--;

if(*it == x) continue;

ret += min(abs(*tmp - x), abs(*it - x));

mp.insert(x);

}

cout << ret << endl;

return 0;

}
```