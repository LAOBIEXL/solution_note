# P1638 逛画展
[[滑动窗口：]]
## 题目描述

博览馆正在展出由世上最佳的 $m$ 位画家所画的图画。

游客在购买门票时必须说明两个数字，$x$ 和 $y$，代表他要看展览中的第 $x$ 幅至第 $y$ 幅画（包含 $x,y$）之间的所有图画，而门票的价钱就是一张图画一元。

Sept 希望入场后可以看到所有名师的图画。当然，他想最小化购买门票的价格。

请求出他购买门票时应选择的 $x,y$，数据保证一定有解。

若存在多组解，**输出 $x$ 最小的那组**。

## 输入格式

第一行两个整数 $n,m$，分别表示博览馆内的图画总数及这些图画是由多少位名师所绘画的。

第二行包含 $n$ 个整数 $a_i$，代表画第 $i$ 幅画的名师的编号。

## 输出格式

一行两个整数 $x,y$。

## 输入输出样例 #1

### 输入 #1

```
12 5
2 5 3 1 3 2 4 1 1 5 4 3
```

### 输出 #1

```
2 7
```

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，有 $n\le200$，$m\le20$。
- 对于 $60\%$ 的数据，有 $n\le10^5$，$m\le10^3$。
- 对于 $100\%$ 的数据，有 $1\leq n\le10^6$，$1 \leq a_i \leq m\le2\times10^3$。

## 分析：
初始化：
起始位置；

==窗口维持==:题目的关键是种类数，所以使用set由于只能判断存在与否，并不能判断存在几个，所以要用map;
```cpp
unordered_map<int, int> ;
每次判断当一个数中0  -  1；kind ++;
当出窗口是 1 - 0， kind --;
```

进窗口；

判断是否合法与出窗口；
如果合法，就更新结果，并且开始出窗口，出完一个元素再次判断是否合法并更新结果，直到不合法后再进窗口；

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
using namespace std;
const int N = 0;


int main()
{
    int n; int m;
    cin >> n >> m;
    unordered_map<int, int> mp;
    vector<int> a(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    int left = 0;
    int kind = 0;
    int right = 0;
    int pos = 0;
    int ret = n;//将结果初始化为最大值；
    while (right < n)
    {
        if (mp[a[right]] == 0) kind++;
        mp[a[right]]++;

        while (kind == m)//循环出窗口与判断，并且循环更新结果；
        {
            /*ret = min(ret, right - left + 1);
            pos = left;*/
            //上面这种方式不可以，因为如果存在多组解需要输出最小的解的情况；
            if (right - left + 1 < ret)
            {
                pos = left;
                ret = right - left + 1; //说白了只有严格小于时再交换；
            }

            if (mp[a[left]] == 1) kind--;
            mp[a[left++]]--;
        }

        right++;
    }
    cout << pos+1 << " " << pos + ret  << endl;


    return 0;
}
```

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<set>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<algorithm>
#include<cmath>
#include<queue>
#include <deque>
#include <stack>
#include<iomanip>
#include <chrono>
#include<random>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
const int N = 1e6 + 10;;
int a[N];
int mp[2010];
int kind;
int len = 1e6;
int ret = -100;

signed main()
{
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	int L = 1, R = 1;
	while (R <= n)
	{
		//进窗口中的进是最后一步，第一步是处理当前位置的right的值；
		if (mp[a[R]] == 0)
		{
			kind++;
			mp[a[R]]++;
		}
		else
		{
			mp[a[R]]++;
		}
		//判断合法：
		while (kind == m)
		{
			if (R - L + 1 < len)
			{
				ret = R;
				len = R - L + 1;
			}
			if (mp[a[L]] == 1)
			{
				mp[a[L]]--;
				kind--;
			}
			else
			{
				mp[a[L]]--;
			}
			L++;
		}
		R++;
	}
	cout << ret - len + 1 << " " << ret << endl;
}
```